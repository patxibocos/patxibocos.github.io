---
layout: post
title: About Scala implicits
---

Implicits in Scala may look (and be) a kind of black magic, but you should give them a try first and understand when they might be used.

# Implicit types

We could say that three cases or usages for Scala implicits exist:
- Implicit conversion type
- Implicit parameters
- Implicit class methods

Let's see them in action one by one.

## Implicit conversions

As a statically typed language, if you try to do something like this in Scala you will get a compilation error:
```
val x: Int = "33"
```

unless you define an **implicit conversion**:
```
implicit def strToInt(str: String): Int = str.toInt
```

note the implicit annotation at the beginning of the definition. This is a mandatory condition to let the compiler check if this implicit method is candidate to get an Int from a String in this case. The function parameter and return types must match the corresponding types of the source and target types.

## Implicit parameters

As you would know, Scala functions allow multiple parameter lists. When using implicits, all the implicit parameters must go in the last list. You could define a function which doubles a number and adds the value of an implicit parameter such as:

```
def doubleAndIncrement(num: Int)(implicit inc: Int) = num * 2 + inc
implicit val x = 3
doubleAndIncrement(2) // 7
```

You could even define the implicit parameters with a default value like this:

```
def doubleAndIncrement(num: Int)(implicit inc: Int = 0) = num * 2 + inc
doubleAndIncrement(2) // 4
```

We can find a real world example of implicit parameters on scala.concurrent.Future.apply:

```
def apply[T](body: =>T)(implicit @deprecatedName('execctx) executor: ExecutionContext): Future[T] = impl.Future(body)
```

When you work with Scala Future, you can easily provide an ExecutionContext by importing:

```
import scala.concurrent.ExecutionContext.Implicits.global
```

which defines:

```
object Implicits {
...
implicit lazy val global: ExecutionContextExecutor = impl.ExecutionContextImpl.fromExecutor(null: Executor)
...
```

Another example applies when working with [Slick](http://slick.lightbend.com/) and when you define a custom type for an specific column. For example, given a Table in which you have the following defined:

```
def created = column[Date]("created")
```

you need to provide an implicit mapper like this (because Slick does not know how to map Date type):

```
private implicit val dateMapper = MappedColumnType.base[Date, java.sql.Timestamp](
  d => new Timestamp(d.getTime),
  d => new Date(d.getTime)
)
```

## Class methods

Implicits also allows you to "inject" or "define" extra methods for a given class (like defining extension methods in other languages). For example:

```
implicit class StringUtils(s: String) {
  def upperCount = s.count(65 to 90 contains _.toInt)
}
```

This allows us to do:
```
"AbCXyZ".upperCount // 4
```

What is happening here is that the String object is being wrapped with StringUtils class. This can be avoided making our implicit class **inherit from AnyVal** as the generated bytecode will not really instante our new class.
